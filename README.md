makeVector <- function(x = numeric()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function() x
        setmean <- function(mean) m <<- mean
        getmean <- function() m
        list(set = set, get = get,
             setmean = setmean,
             getmean = getmean)
}


cachemean <- function(x, ...) {
        m <- x$getmean()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- mean(data, ...)
        x$setmean(m)
        m
}

makeCacheMatrix
cacheSolve
makeCacheMatrix <- function(x = matrix()) {
## Write a short comment describing this function :
## The function makeCacheMatrix takes an invertible matrix x in input (a default matrix 0*0 is set)
## Then it set an object, I, which will store the Inverse of x after having compute it with the 2nd function
## Then 3 functions are defined and associated in a list that is the output of makeCacheMatrix.
## These 3 functions contained in the list will be used in the cacheSolve function
## >> get() will keep the intial matrix in input in order to compute (or not) its inverse
## >> setInverse() will assign the value of the inverse of x (computed with cacheSolve the first time 
## used) to I
## >> getInverse() will be used to cache I in the output list of makeCacheMatrix

makeCacheMatrix <- function(x = matrix()) { #x is an invertible matrix
        I <- NULL # set a value to the inverted matrix
        get <- function() {
                x
        } # set a function that get and cache the matrix in input of makeCacheMatrix
        setInverse <- function(Inverse){
                I <<- Inverse
        } # assign the input value of setInverse to I
        getInverse <- function(){
                I
        } # set a function that get the inverted matrix I (either NULL or cache if previously computed)
        list( get = get, 
              setInverse = setInverse, 
              getInverse = getInverse) 
        # create a list of functions needed to compute and store an inverted matrix 
}


## Write a short comment describing this function
## Write a short comment describing this function :
## cacheSolve take in input the list generated by makeCacheMatrix (stored in a named R object)
## It first get the value of I (either NULL or the inverse of the input of makeCacheMatrix)
## Then if I is NOT NULL (!is.null(I)), i.e. if I is a cached matrix (an inverse),
## it will print a message to the console saying "getting cached inverted matrix"
## and return the value of the inverse already computed before, and skip the rest. If the message appears, it will 
## underline the fact that the function hasn't computed the inverse again but it has only get back the cached value
## If I is NULL, it will skip this first part and get the value of the input invertible matrix 
## (input of makeCacheMatrix) and the compute its inverse (with the solve function).
## Before the end, it will store the value of the inverse computed with the setInverse function
## Finaly, it will print the value of the inverse.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        I <- x$getInverse() #get the inverted matrix cached or NULL
        if(!is.null(I)){ # ask if the inverted matrix as already been computed or not. if already computed then:
                message("getting cached inverted matrix") 
                # print a message to show that the inverted matrix is not computed again
                return(I) # print the inverted cached matrix and skip the computation
        }
        data <- x$get() #if not already computed, get back the input cached matrix to compute its inverse
        I <- solve(data, ...) #compute the inverted matrix of the cached matrix
        x$setInverse(I) #set the value of the inverse computed in I in order to cache it
        I # print the inverse computed
